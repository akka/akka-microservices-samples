= Event sourcing
:toc:
:toc-title: ON THIS PAGE
:toclevels: 2

include::ROOT:partial$include.adoc[]

== Event sourcing concepts

See an link:https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)?redirectedfrom=MSDN[introduction to EventSourcing] at MSDN.

Another excellent article about “thinking in Events” is link:https://hackernoon.com/events-as-first-class-citizens-8633e8479493[Events As First-Class Citizens] by Randy Shoup. It is a short and recommended read if you’re starting developing Events based applications.

Event sourcing documentation in the link:{akka}/typed/persistence.html#introduction[Akka Reference documentation for Akka Persistence].

== Describing entities

A difference to persistence based on Create-Read-Update-Delete (CRUD) data-stores is that we don't need to map our imagined entities to a database model up-front. Instead, we model the entities and the events that affect their state.

Our shopping cart entity is implemented in `ShoppingCart`. Its state keeps track of items with their count and the optional checkout timestamp ('Instant').

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ShoppingCart.scala[tag=state]
----

ifdef::todo:[include something like https://www.lagomframework.com/documentation/1.6.x/scala/ES_CQRS.html and https://www.lagomframework.com/documentation/1.6.x/scala/ESAdvantage.html]


== Updating entities

To update an entity's state we use commands from the outside and events on the inside.

=== Commands

This entity state can be changed only via commands to it. The commands are the "external" API of an entity. Commands request state changes, but they might lead to different events on the entity depending on the entities current state.

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ShoppingCart.scala[tag=commands]
----

<1> All commands extend a common marker interface.

Our example handles commands differently whether the shopping cart is checked out or not. This command handler implements the "external" API of our entity.

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ShoppingCart.scala[tag=commandHandler]
----

For an open shopping cart the `ReplyEffect` reacts on the commands by deciding which effect they should have on the entity.

Our business logic allows only items to be added which are not in the cart yet and require a positive quantity. If an `AddItem` command is accepted, the `Effect.persist` applies an event to the cart's state and makes sure this event is stored before replying to the command.

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ShoppingCart.scala[tag=openShoppingCart]
----

<1> Matching the `AddItem` command
<2> Persisting the `ItemAdded` event and replying to the sender

See all available effects in the link:{akka}/typed/persistence.html#effects-and-side-effects[Akka reference documentation].

=== Events

The events represent changes of the entity's state and are the only way to change it. The entity creates events from commands, other parts of the application may listen to the created events. Other parties can't send events.

The events get continuously persisted to the Event Journal datastore, while the entity state is kept in memory. In case of a restart the latest state gets rebuilt by replaying the events from the Event Journal.

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ShoppingCart.scala[tag=events]
----

Aligning with the command handler above, the entity's event handler reacts on events and updates the state. Notice that there are no decisions on events, they are applied without any checks.

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ShoppingCart.scala[tag=evenHandler]
----



The state, commands and events of the entity are marked as `CborSerializable` which is configured to use the built-in CBOR serialization whenever these need to be written to the datastore or sent between nodes within the Akka cluster. The interface is configured in the `application.conf` file to enable CBOR serialization.

[source,hocon]
----
include::example$shopping-cart-service-scala/src/main/resources/application.conf[tag=cbor]
----





== TODO

The write model is a shopping cart.

The implementation is based on a sharded actor: each `ShoppingCart` is an link:{akka}/typed/cluster-sharding.html[Akka Cluster Sharding] entity. The entity actor `ShoppingCart` is an link:{akka}/typed/persistence.html[EventSourcedBehavior].

Events from the shopping carts are tagged and consumed by the read model.


== Full source

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ShoppingCart.scala[]
----

