= What makes up a service?


include::partial$include.adoc[]


A service is made up by its API (request and response types, strict vs stream, synchronous vs asynchronous), and discovery information (URL, topic name).

To communicate the API consistently, we recommend using schema-first approaches. The schemas are to be shared by the service implementation and its clients. From the schema the implementing code is generated and used to implement the service and the client code. With this approach the service, and the clients don't share any code or dependencies.

== Synchronous Services

The first steps of the xref:microservices-tutorial:index.adoc[Implementing Microservices with Akka tutorial] illustrate building service APIs for synchronous communication for use cases which require an instant reply. Most often, synchronous communication sends a single request and expects a single reply. Other cases open communication channels for continued communication with possibly ongoing replies.

Synchronous communication gives results and errors immediately so the client can react before continuing its processing, but that often means the client doesn't progress until it received the response.

=== gRPC

xref:grpc-services.adoc[gRPC services] use Protobuf as their language-agnostic schema which translates to efficient serialization.
Protobuf can also be used as a serialization format for messages on Kafka topics. So that both producer and consumer agree on the format.

Akka gRPC adds plug-ins to the build system of the application to generate Java or Scala classes corresponding to the Protobuf schema.

=== HTTP with JSON / RESTful

The ubiquitous communication protocol is HTTP with text-based messages in JSON. Even though JSON lacks a commonly used schema description, its simplicity, human-readability and support in Javascript has made the de-facto standard for synchronous communication over system boundaries.

== Asynchronous Services

Asynchronous service communication xref:isolation.adoc[decouples] services even further. Sending and receiving is decoupled in time and both parts do not necessarily act at the same time.
To ensure delivery of messages asynchronous communication may require extra measures like sending acknowledgements.

ifdef::todo[TODO:
* Kafka
* Show protobuf (implemented in Cloudflow, examples in Alpakka Kafka)
* Confluent Cloud Protobuf https://www.confluent.io/blog/using-protobuf-in-confluent-cloud/
* Broker discovery https://doc.akka.io/docs/alpakka-kafka/current/discovery.html
]

== Service Discovery
[#service-discovery]

Service Discovery is the mechanism service clients will use to locate and consume a xref:mobility.adoc[movable] service. Service Discovery is a key building block to {glossary-location-transparency}[Location Transparency] {glossary-location-transparency}[{tab-icon}, window="tab"]. Service clients relying on Service Discovery no longer need to have previous knowledge of the address of a service and, instead, use a discovery mechanism any time they need to use that address.

The most common discovery mechanism is DNS in which clients lookup an address resolution given a hostname. In DNS, the most common registries are `DNS-A` and `DNS-AAAA` records. The `DNS-SRV` records not only resolve the address but also a port. The `DNS-SRV` record type is a perfect match for orchestration platforms where services not only move across hosts but may also be bound to random ports are they are moved. One last characteristic of `DNS-SRV` records is the addition of extra https://en.wikipedia.org/wiki/SRV_record#Record_format[metadata] https://en.wikipedia.org/wiki/SRV_record#Record_format[{tab-icon}, window="tab"] including the application protocol (aka `service`) and the transport protocol (aka `proto`). `DNS-SRV`-based Service Discovery is a common strategy in xref:deployment-and-container-orchestration.adoc#kubernetes[Kubernetes] deployments.

Service Discovery look-ups hit a Service Registry that keeps an up-to-date list of addresses providing a given service. In Kubernetes, for example, when a Pod is xref:how-to:health-checks.adoc[ready] the DNS registry is updated, so a new Service Discovery look-up for that service can now return this new Pod address and port. the Service Registry may resolve the look-up request with one or many valid addresses, then the client can use any load-balancing or caching mechanism it prefers with that list.

The above describes a scenario of client-side Service Discovery where the service publishes a detailed registry of all the instances serving it.

With server-side Service Discovery, on the other hand, the service implementor provides a single, stable entry point and handles the discovery, but also the load-balancing, internally.

ifdef::todo[TODO: Transport information coordinates (URL, HTTP method, broker & topic), serialization]

ifdef::todo[TODO: Service descriptor agnostic to transport?]

== Protecting our Service

A Service may experience transient failure or degradation due to excessive load, GC pauses, etc... in that case, clients will retry the failed request, which will increase the load. Instead, in order to let the service recover from the transient failure as fast as possible, clients should use xref:circuit-breakers.adoc[Circuit Breakers].

ifdef::todo[== TODO: Structuring our Service]
ifdef::todo[TODO: Anti-corruption layer (link to DDD.adoc)]
