= VIII: Projection calling gRPC service
:page-supergroup-java-scala: Language

include::ROOT:partial$include.adoc[]

On this page, we will add another Projection from the events of the `ShoppingCart` entity. This Projection calls another service when the shopping carts are checked out. We will also add the other service, the `ShoppingOrderService` that provides the gRPC service that is called.

.This part of the xref:overview.adoc[full example] will focus on the gRPC client in the `SendOrderProjection`.
[caption=""]
image::example-projection-grpc-client.png[Example gRPC client]

On this page you will learn how to:

* call another service with xref:concepts:akka-grpc.adoc[Akka gRPC]
* repeat how to implement a gRPC service by adding the `ShoppingOrderService`

== Source downloads

If you prefer to simply view and run the example, download a zip file containing the completed code:

[.tabset]
Java::
+
.Source downloads:
****
* link:_attachments/5-shopping-cart-projection-kafka-java.zip[Source] that includes all previous tutorial steps and allows you to start with the steps on this page.
* link:_attachments/6-shopping-cart-complete-java.zip[Source] with the steps on this page completed.
****

Scala::
+
.Source downloads:
****
* link:_attachments/5-shopping-cart-projection-kafka-scala.zip[Source] that includes all previous tutorial steps and allows you to start with the steps on this page.
* link:_attachments/6-shopping-cart-complete-scala.zip[Source] with the steps on this page completed.
****


== Another gRPC service

Let's add another service that is responsible for the orders of the shopping carts.

The xref:template.adoc#seed-template[template download] (or other source downloads) includes a directory named `shopping-order-service`. Open the `shopping-order-service` xref:template.adoc#intellij[in IntelliJ in the same way as you did with the shopping-cart-service].

First, define the interface of the service in a protobuf service descriptor. It should be located in the `src/main/protobuf/ShoppingOrderService.proto` in the new `shopping-order-service` project.

[source,protobuf]
----
include::example$shopping-order-service-scala/src/main/protobuf/ShoppingOrderService.proto[]
----

Generate code by compiling the project:

[.group-java]
[source,shell script]
----
mvn compile
----

[.group-scala]
[source,shell script]
----
sbt compile
----

Implement the `ShoppingOrderService` in a new class `ShoppingOrderServiceImpl`:

[.tabset]
Java::
+
.src/main/java/shopping/order/ShoppingOrderServiceImpl.java:
[source,java,indent=0]
----
include::example$shopping-order-service-java/src/main/java/shopping/order/ShoppingOrderServiceImpl.java[]
----

Scala::
+
.src/main/scala/shopping/order/ShoppingOrderServiceImpl.scala:
[source,scala,indent=0]
----
include::example$shopping-order-service-scala/src/main/scala/shopping/order/ShoppingOrderServiceImpl.scala[]
----

Similar to the xref:grpc-service.adoc[gRPC server for the ShoppingCartService] we need to initialize the gRPC server. Add a `ShoppingOrderServer` [.group-scala]#object# [.group-java]#class#:

[.tabset]
Java::
+
.src/main/java/shopping/order/ShoppingOrderServer.java:
[source,java,indent=0]
----
include::example$shopping-order-service-java/src/main/java/shopping/order/ShoppingOrderServer.java[]
----

Scala::
+
.src/main/scala/shopping/order/ShoppingOrderServer.scala:
[source,scala,indent=0]
----
include::example$shopping-order-service-scala/src/main/scala/shopping/order/ShoppingOrderServer.scala[]
----

and call the `ShoppingOrderServer.init` from `Main`:

[.tabset]
Java::
+
[source,java,indent=0]
----
include::example$shopping-order-service-java/src/main/java/shopping/order/Main.java[]
----

Scala::
+
[source,scala,indent=0]
----
include::example$shopping-order-service-scala/src/main/scala/shopping/order/Main.scala[]
----

The `grpc.port` configuration is defined in `local1.conf`, which is included in the generated template project.

== Call service from Projection

The new Projection in the `shopping-cart-service` will be similar to what we developed in the xref:projection-kafka.adoc[previous step], but it will call the `ShoppingOrderService` for `ShoppingCart.CheckedOut` events.

First we need to include the service definition. Copy the `ShoppingOrderService.proto` file from the `shopping-order-service` to the `shopping-cart-service/src/main/protobuf` directory and generate code by compiling the `shopping-cart-service` project:

[.group-java]
[source,shell script]
----
mvn compile
----

[.group-scala]
[source,shell script]
----
sbt compile
----

Add a `SendOrderProjectionHandler` class in the `shopping-cart-service` project. This is the Projection `Handler` for processing the events:

[.tabset]
Java::
+
.src/main/java/shopping/cart/SendOrderProjectionHandler.java:
[source,java,indent=0]
----
include::example$shopping-cart-service-java/src/main/java/shopping/cart/SendOrderProjectionHandler.java[]
----

Scala::
+
.src/main/scala/shopping/cart/SendOrderProjectionHandler.scala:
[source,scala,indent=0]
----
include::example$shopping-cart-service-scala/src/main/scala/shopping/cart/SendOrderProjectionHandler.scala[]
----

<1> `ShoppingOrderService` is the gRPC client

<2> retrieve the full shopping cart information from the entity

<3> call the `ShoppingOrderService`

In the order we need to include the list of items and their quantities. That information is not included in the `ShoppingCart.CheckedOut` event, but we can retrieve it by asking the `ShoppingCart` entity for it.

If the call to the `ShoppingOrderService` fails the returned [.group-scala]#`Future[Done]`# [.group-java]#`CompletionStage<Done>`# is failed and the Projection is automatically restarted from the previously saved offset. This will result in that the call to the `ShoppingOrderService` will be retried. Since the Projection has `at-least-once` semantics the `ShoppingOrderService` must be idempotent, i.e. handle duplicate order attempts for the same `cartId`.

== Initialize the Projection

The tagging of the events is already in place from a xref:projection-query.adoc#tagging[previous step].

Place the initialization code of the Projection in an `SendOrderProjection` [.group-scala]#object# [.group-java]#class#:

[.tabset]
Java::
+
.src/main/java/shopping/cart/SendOrderProjection.java:
[source,java,indent=0]
----
include::example$shopping-cart-service-java/src/main/java/shopping/cart/SendOrderProjection.java[]
----

Scala::
+
.src/main/scala/shopping/cart/SendOrderProjection.scala:
[source,scala,indent=0]
----
include::example$shopping-cart-service-scala/src/main/scala/shopping/cart/SendOrderProjection.scala[]
----

In the `Main` you can invoke the `SendOrderProjection.init` and create the gRPC client for the `ShoppingOrderService` like this:

[.tabset]
Java::
+
[source,java,indent=0]
----
include::example$shopping-cart-service-java/src/main/java/shopping/cart/Main.java[tag=SendOrderProjection]
----

Scala::
+
[source,scala,indent=0]
----
include::example$shopping-cart-service-scala/src/main/scala/shopping/cart/Main.scala[tag=SendOrderProjection]
----

The reason for placing the initialization of `orderServiceClient` in a `protected` method is that tests can then replace it with a stub implementation.

The gRPC client is using service discovery to locate the `ShoppingOrderService`. For local development add the following to `src/main/resources/local-shared.conf`, which is loaded when running locally:

[source,hocon]
----
include::example$shopping-cart-service-scala/src/main/resources/local-shared.conf[tag=grpc]
----

== Run locally

Start Cassandra and Kafka, unless it's already running:

[source,shell script]
----
docker-compose up -d
----

Run the `shopping-order-service` with:

[.group-java]
[source,shell script]
----
# make sure to compile before running exec:exec
mvn compile exec:exec -DAPP_CONFIG=local1.conf
----

[.group-scala]
[source,shell script]
----
sbt -Dconfig.resource=local1.conf run
----

Try the new order service directly with `grpcurl`:

[source,shell script]
----
grpcurl -d '{"cartId":"cart1", "items":[{"itemId":"socks", "quantity":3}, {"itemId":"t-shirt", "quantity":2}]}' -plaintext 127.0.0.1:8301 shoppingorder.ShoppingOrderService.Order
----

Keep the `shopping-order-service` running, and in another terminal run the `shopping-cart-service` with:

[.group-java]
[source,shell script]
----
# make sure to compile before running exec:exec
mvn compile exec:exec -DAPP_CONFIG=local1.conf
----

[.group-scala]
[source,shell script]
----
sbt -Dconfig.resource=local1.conf run
----

Use the checkout in the shopping cart service with `grpcurl` (note the different port):

[source,shell script]
----
grpcurl -d '{"cartId":"cart1", "itemId":"scissors", "quantity":1}' -plaintext 127.0.0.1:8101 shoppingcart.ShoppingCartService.AddItem

grpcurl -d '{"cartId":"cart1"}' -plaintext 127.0.0.1:8101 shoppingcart.ShoppingCartService.Checkout
----

In the terminal of the `shopping-order-service` you should see the log of the order:

----
Order 12 items from cart cart1
----

=== Stop the service

When finished, stop the `shopping-cart-service` and `shopping-order-service` with `ctrl-c`. Stop Cassandra and Kafka with:

[source,shell script]
----
docker-compose down
----

== Learn more

This is the end of the tutorial.

* xref:concepts:internal-and-external-communication.adoc[Internal and External Communication concepts].
* {akka-grpc}/client/index.html[Akka gRPC client reference documentation {tab-icon}, window="tab"].
* {akka-projection}/[Akka Projection reference documentation {tab-icon}, window="tab"].
